pub mod rpc;

#[derive(Clone, Debug)]
pub struct State {
    workers: Vec<crate::worker::rpc::Remote>,
}
impl State {
    pub fn new() -> Self {
        Self {
            workers: Vec::new(),
        }
    }
}

// This is the service definition. It looks a lot like a trait definition.
// It defines one RPC, hello, which takes one arg, name, and returns a String.


// This is the type that implements the generated Service trait. It is the business logic
// and is used to start the server.

/*
#[allow(dead_code)]
//async fn run(mut spawn: impl futures::task::Spawn + futures::task::SpawnExt + Clone + 'static) -> io::Result<()> {
async fn run() -> io::Result<()> {
    // bincode_transport is provided by the associated crate bincode-transport. It makes it easy
    // to start up a serde-powered bincode serialization strategy over TCP.
    let router_server_transport = tarpc_bincode_transport::listen(&"0.0.0.0:0".parse().unwrap())?;
    let addr = router_server_transport.local_addr();

    let server_impl = rpc::Server::new();

    // The server is configured with the defaults.
    let server = server::new(server::Config::default())
        // Server can listen on any type that implements the Transport trait.
        .incoming(router_server_transport)
        // Close the stream after the client connects
        .take(1)
        // serve is generated by the service! macro. It takes as input any type implementing
        // the generated Service trait.
        .respond_with(rpc::serve(server_impl));

    tokio_executor::spawn(server.unit_error().boxed().compat());
    let router_client_transport = await!(tarpc_bincode_transport::connect(&addr))?;

    // new_stub is generated by the service! macro. Like Server, it takes a config and any
    // Transport as input, and returns a Client, also generated by the macro.
    // by the service mcro.
    let mut router_client = await!(rpc::new_stub(client::Config::default(), router_client_transport))?;

    let worker_conn_string = "127.0.0.1:7878";

    let worker_server_transport = tarpc_bincode_transport::listen(&worker_conn_string.parse().unwrap())?;
    let mut worker_server =  server::new(server::Config::default())
        // Server can listen on any type that implements the Transport trait.
        .incoming(worker_server_transport)
        // Close the stream after the client connects
        .take(1)
        // serve is generated by the service! macro. It takes as input any type implementing
        // the generated Service trait.
        .respond_with(crate::worker::rpc::serve(crate::worker::rpc::Server::new()));
    tokio_executor::spawn(worker_server.unit_error().boxed().compat());

    // The client has an RPC method for each RPC defined in service!. It takes the same args
    // as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    let hello = await!(router_client.hello(context::current(), "Stim".to_string()))?;
    let reg_response = await!(router_client.register_worker(context::current(), worker_conn_string.to_string()))?;

    println!("{}", hello);

    Ok(())
}

#[test]
fn test_service() -> std::io::Result<()> {
    tarpc::init(futures::compat::TokioDefaultSpawner);
    tokio::run(run()
                   .map_err(|e| eprintln!("Oh no: {}", e))
                   .boxed()
                   .compat(),
    );
    Ok(())
    //pool.run(run(pool.clone()).map_err(|e| eprintln!("Oh no: {}", e))).map_err(|_| { std::io::Error::new(std::io::ErrorKind::Other, "lol")})
}

*/